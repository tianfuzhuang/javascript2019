###     var let const 各自特点及区别
        + var:
            var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问.
            当通过var创建一个变量的时候，会进行预解析（变量提升）
            因为var会预解析，所以变量会当做属性存到全局的活动变量对象下(window下)
            不支持块级作用域
            不会主动存每次循环的值



        + let:
            let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
            当通过var创建一个变量的时候，不会进行预解析（不会变量提升）不会在window下挂属性
            在定义变量之前访问这个变量，之前访问的空间叫暂存死区
            支持块级作用域
            会把每次循环的值存储起来
            不能声明同名的变量、函数、参数


        + const:常量(不可变的量)
            const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改.
            当声明一个变量，不允许改变的时候就使用const就定义
            不能声明同名的变量、函数、参数
            const box = document.getElementById('box');
            注意:
            const赋值的数据，它只会监控这个数据的地址.
### 块级作用域
#### 为什么需要块级作用域
     + ES5中通有全局作用域和函数作用域,没有块级作用域,这导致很多场景不合理,比如内层变量可能覆盖外层变量.
     + ES6 中新增了块级作用域。块作用域由 { } 包括，if语句和 for语句里面的{ }也属于块作用域。
     + 块:{}
            在块套块中，子块有函数，如果在父块或者父块的上方访问这个函数
            那么都是undefined
            如果在子块的下方访问这个函数，就能找到这个函数

### 单例
 + 单例模式:
 + 单例模式解决了分组的问题，让每个对象       有了自己独立的命名空间，但是不能批量       生产，每一个新的对象都要重新写一份一模一   样的代码。
            + 单例:单独的实例
            + 实例:描述具体的是一个事务       + 一个具体的东西（具体）
            构造函数:抽象一个类的封装过程     + 鸟类:老鹰 黄鹂...  老师（教书育人..）
 
 
 + 高级单例模式:让当前的实例功能更加强大,还可以隐藏或者暴露细节信息
 + 可以解决命名冲突的问题
 + 高级单例模式如何写?
 (function(){
 return{
 }
 })()
 + 解决命名冲突的问题:
 1.封闭空间(把变量或者函数放到函数中)
 2.命名空间
 ### 工厂模式
 + 这时候就有了工厂模式

 + 即：把实现同一事情的相同代码，放到一个函数中，以后如果再想实现这个功能，就不需要重新编写这些代码了，只要执行当前的函数即可，
 + 这就是函数的封装，体现了高内聚、低耦合的思想：减少页面的中的冗余代码，提高代码的重复利用率：

### 面向对象编程
+ 原型: 在js中，所有的class(类)都是函数模拟出来的
        当声明一个函数的时候，这个函数自身有一些属性或者方法(天生自带的)
        其中有一个属性叫做prototype,它的** 值为对象 ** 
        这个prototype就叫原型，也就是说函数身上才有原型
        *** 函数原型下的属性或者方法只给它(构造函数)的实例化对象使用。
        Obejct.prototype.__proto__ 为null，找到Obejct的原型下如果没有某个属性或者方法就真的没有了

+ 原型链:
     __proto__  实例化对象下都有 __proto__ ，
    这个属性全等于 实例的构造函数的原型

+ kitty.skill  -> kitty.__proto__ -> Cat.prototype
        Cat.prototype = {
            __proto__:构造函数的原型
        }
        Object.prototype
        实例有原型链，函数有原型，原型又是一个对象，对象它就是实例
        实例又有原型链，找到构造函数的原型，Object.prototype.__proto__ = null

+ new 是函数一元运算符，专门运算*函数*的
        使用new之后会调用函数，就算不加()也会调用执行
        使用new之后，this变成了实例，实例就是一个对象(空白对象)
        使用new之后，函数默认返回值为实例化对象，就不是undefined
        如果return后面有值，为原始类型，返回结果还是实例，如果
        return后面的值为引用类型，返回的结果就是return后的引用类型
        {}  new Obejct  new 函数

### 闭包
+ 闭包:抽象
            闭包的定义:   
                1.函数就是闭包(局部变量不被外界所污染)
                2.函数可以使用函数之外定义的变量(教科书上的)
                3.
                    (function(i){
                        btn[i].onclick = function(){
                            alert(i);
                        }
                        btn[i].onclick = null;
                    })(i)    某个变量不被浏览器垃圾回收机制回收

                4.
                    函数套函数，子函数引用父函数的参数或者变量并且子函数被外界所引用
                    这个时候父级就形成闭包环境(父级的执行栈不被销毁)，父级的参数或者变量不会被浏览器垃圾回收机制回收
                    此时打印父级的返回值查看scopes下有个closure，closure就是闭包
            闭包的应用
                存值
                栈溢出 -> 用完变量就释放这个变量
