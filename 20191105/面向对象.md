 ### 函数的三种角色

+ 第一种: 普通的函数,能够调用的角色,函数定义，形成栈空间函数执行，形成私有作用域（堆空间）、形参赋值、预解释、代码自上而下执行、堆空间销毁（如果内部引用类型地址被外部变量占用，不销毁空间）:fuction fn(){}

+ 第二种:构造函数
  + new 构造出来的函数 .
    + new 是函数的一元运算符,只能运算函数 
     + this指向实例 
     + 默认return是实例,如果手动添加return,return否面是引用类型,那么返回的也是引用类型,如果return后面是基本类型那么返回回来的还是实例)
     + 加不加括号都能执行函数,括号主要是为了传参
     + new 出来的构造函数需要大写
     fn.prototype 公共的属性或者方法挂在这个构造函数的原型下
+ 第三种: Function的实例:在函数的原型下有个属性,constructor,这个属性指向构造函数 但是当前的constructor并不是100%准确的,它的指向仅仅只是一个指向构造函数的方向(仅仅是个参考,很容易被修改) Fn.prototype = {} 注意的是在对象赋值给构造函数原型的时候,constructor指向会被修改,指向的是Object,所以在真实项目我们会手动修正constructor的指向. Fn.prototype={constructor:Fn}

### 内置类:浏览器自带的类
+ 所有的类型都是构造函数构造出来的.
### hasOwnProperty
  + Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含自身属性。
  + 用法: for in的时候会美剧原型,会把自定义的属性或者方法美剧出来
  + 查看某个属性或者方法是否为对象自身的(面向对象中)即查看某个属性是共有的 还是私有的
  + 在for in的过程中,如果不能确定构造函数是原型下是否有自定义的属性或者方法,那么建议加一个if判断,判断枚举的属性是自身的 for  +  (let attr in obj){
    if(obj.hasOwnProperty(attr)){
        console.log(attr)
    }
}   
  + 封装一个hasPubProperty  某个属性是公共的
  + function hasPubProperty(obj,attr){
    return !obj.hasOwnProperty(attr);
}

### this指向实例
1.window 
  + 全局打印this
  + 函数 + 括号
  + 定时器
  + (function(){})() 函数+括号

2.事件触发的元素
  + 只要是事件函数内的this都指向事件触发的元素
3.点前面的主
  + var o = {
  + user:"追梦子",
  + fn:function(){
  + console.log(this.user);  //追梦子
  }
  }
  o.fn();
 4.实例
    + 构造函数下的this是实例   new Fn
    + 构造函数原型的this也是实例 (实例调用)
    + Fn.prototype.say()  this为
    + Fn.prototype


 5.箭头函数
    + 指向的是声明箭头函数的上下文this
    + 没有arguments，不能new
    + Fn.prototype.name1 = function(){
    console.log(this);//Fn.prototype
    let fn = ()=> {
        console.log(this);//Fn.prototype Fn{}
    }
    fn();
};

+ 箭头函数：箭头函数本身是没有this和
  arguments的，在箭头函数中引用this实际上是调用的是定义时的上一层作用域的this

### 改写this
+ 当一个函数创建的时候,天生自带的方法,其中有call,apply,bind方法call:
+ call:
       有若干个参数:
         第一个参数:
            修改this的指向
         第二个参数:
            函数的实参
+ apply:
        有2个参数:
         第一个参数:
            修改this的指向
         第二个参数:
            数组,数组里面放的是实参
+ bind:(惰性函数,科利华函数,高阶函数)
        多个参数
          第一个参数:
             修改this的指向
          第二个参数之后:
             函数的实参
        他返回的是新函数,值要调用返回的函数才能执行函数内的代码
+ 相同点:都是改变this指向的方法
+ 细节:
      在使用他们修改this的时候,不要传null和undefined,因为传了也不认还是走默认的window