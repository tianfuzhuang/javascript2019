### 正则表达式:
+ 专门用来检索字符串的一种规则（更擅长处理模糊范围的字符串）;
+ 例: 
     + 挑出字符串中的数字
``` 
 let str = 'sdfdfdfsdasdf123dfdf1';
 let ary = str.match(/\d+/g);
 console.log(ary);//["1", "2", "3", "1"];
 ```
+ 字面量的写法:
            new RegExp(规则【可以为字符串的，可以进行字符串拼接】,修饰符) -> new实例的写法;
+ //与newRegExp的应用
+   let str = 'abc';
+   let aa = 'a';
+   RegExp
    // console.log(/aa/); // 找的是字符aa(正则里面放的是不带引号的字符串或者规则)
    // console.log(new RegExp(aa)); //找的是变量aa，其实就是找字符串a
+ \ ：转义字符   把正则中有特殊含义的字符 转成字符本身(不再有任何特殊的含义),转义符转的是\后面的字符

### 正则拥有的方法:
+ //.exec(字符串)
     找到正则匹配的字符串（首次出现的字符 只找一次），并且放到数组中(返回的是数组)
   例子:
    ```
   let str = 'dh8137289371299dx1';
    console.log(/1/.exec(str));
    '1'为找到的字符, index: '1'首次出现的位置,  input:整个字符 找的是'1'所以length是1   groups:undefined
    //["1", index: 3, input: "dh8137289371299dx1"
    groups:undefined]
    

+ //.test(字符串)
    查看字符串中是否有规则匹配项，如果有就返回true，否则false;
    例:
    //test方法
    console.log(/z/.test(str));// 找当前字符串中是否有z这个字符 找不到就为false;
    console.log(/x/.test(str));//找到就为true,检测结果是一个布尔值;

+ string.match(//)方法 是字符串的方法找到正则匹配的字符并且把他们放到数组中(返回值是一个数组)
    + 他的特征:
        +  懒惰: 
            你让它找一个，绝对不会找第二个，你让它找一堆，它绝对不会找第二堆

        +  贪婪:
            只要符合某个规则就不停的找，直到找不到为止
        +  i : 忽略大小写  ignoreCase
        例: let str = '37z89z37Z218Z9';
        console.log(str.match(/z/gi));//查找全局是否有z(不管大写还是小写);

+     //replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。
        //string.replace(''或者放正则,'替换字符'或者放函数)  替换
        let str = 'haha,呵呵';
        console.log(str.replace(/haha|呵呵/g, function (a) {
            let temp = '';
            for (let i = 0; i < a.length; i++) {
                temp += '*';

            }
            return temp;

        }));

/* replace的细节:默认情况下,函数的
函数的第一个参数就是每次匹配的字符，如果匹配多次那么会多次调用 */
+ 
        + replace的细节:
            *默认*情况下，函数的
                第一个参数是每次匹配字符
                第二个参数是匹配字符索引
                第三个参数是整个字符串
                第四个参数是undefined

        +    如果有分组
              
                第一个参数是每次匹配字符
                第二个参数是第一个分组，
                之后有几个分组，参数就是分组项
                直到分组读完就正常走索引、整个字符串、undefined

### [] 
        []中的字符在正则中是找任意一个字符
        [123] -> 要么找1要么找2要么找3

        也可以使用多少 - 多少的写法来写

        [0-9] -> \d  ascll码来编排的

        小写英文 : [a-z]
        大写英文 : [A-Z]
        如果要拿到大写和小写的字符[A-z] ×  因为acsll码的91-96是别的字符不算字母
        要[A-Za-z]写  √
         ^ 字符串开头
        $ 字符串结尾

### {}
+  {} 代表量词
        描述{}前面字符的数量
        {m,}  最少m个，最多不限
        + -> {1,}
        {m,n} -> {2,5}
        {n} 最少出现n次，最多也是出现n次
        ? 最少可以没有，最多出现1次 -> {0,1}
        * 最少可以没有，最多无限 -> {0,}
### ^ 开头
+ 如果^在中括号中，那么代表排除
    */    
    let str = 'a12ca456ca6789ca123456caca1ca78c';
    console.log(str.match(/a[^123]+c/g));//a开头c结尾，中间排除1